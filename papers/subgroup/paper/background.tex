% !TEX root = subgroup.tex

\section{Background}

\subsection{Groups, orders, and generators}
\label{sec:group-background}

The two types of groups used for Diffie-Hellman key exchange in practice are
multiplicative groups over finite fields (``mod $p$'') and elliptic curve
groups. We focus on the ``mod $p$'' case, so a group is typically specified by
a prime $p$ and a generator $g$, which generates a multiplicative subgroup
modulo $p$.  Optionally, the group order $q$ can be specified; this is the
smallest positive integer $q$ satisfying $g^q \equiv 1 \bmod p$.  Equivalently,
it is the number of distinct elements of the subgroup $\{g, g^2, g^3, \dots
\bmod p\}$.

By Lagrange's theorem, the order $q$ of the subgroup generated by $g$ modulo
$p$ must be a divisor of $p-1$. Since $p$ is prime, $p-1$ will be even, and
there will always be a subgroup of order 2 generated by the element $-1$. For
the other factors $q_i$ of $p-1$, there are subgroups of order $q_i \bmod p$.
One can find a generator $g_i$ of a subgroup of order $q_i$ using a randomized
algorithm: try random integers $h$ until $h^{(p-1)/q_i} \ne 1 \bmod p$; $g_i =
h^{(p-1)/q_i} \bmod p$ is a generator of the subgroup.  A random $h$ will
satisfy this property with probability $1 - 1/q_i$.

In theory, neither $p$ nor $q$ is required to be prime. Diffie-Hellman key
exchange is possible with a composite modulus and with a composite group order.
In such cases, the order of the full multiplicative group modulo $p$ is
$\phi(p)$ where $\phi$ is Euler's totient function, and the order of the
subgroup generated by $g$ must divide $\phi(p)$. Outside of implementation
mistakes, Diffie-Hellman in practice is done modulo prime $p$.
%\looseness=-1

\subsection{Diffie-Hellman Key Exchange}

Diffie-Hellman key exchange allows two parties to agree on a shared secret in
the presence of an eavesdropper~\cite{diffie1976new}. Alice and Bob begin by
agreeing on shared parameters (prime $p$, generator $g$, and optionally group
order $q$) for an algebraic group.  Depending on the protocol, the group may be
requested by the initiator (as in IKE), unilaterally chosen by the responder
(as in TLS), or fixed by the protocol itself (SSH originally built in support
for a single group).

Having agreed on a group, Alice chooses a secret $x_a < q$ and sends Bob $y_a =
g^{x_a}\bmod p$.  Likewise, Bob chooses a secret $x_b < q$ and sends Alice $y_b =
g^{x_b}\bmod p$. Each participant then computes the shared secret key
$g^{x_a x_b}\bmod p$.%  \looseness=-1 

Depending on the implementation, the public values $y_a$ and $y_b$ might be
\emph{ephemeral}---freshly generated for each connection---or \emph{static} and
reused for many connections.

\subsection{Discrete log algorithms}

The best known attack against Diffie-Hellman is for the eavesdropper to compute
the the private exponent $x$ by calculating the discrete log of one of Alice or
Bob's public value $y$. With knowledge of the exponent, the attacker can
trivially compute the shared secret.  It is not known in general whether the
hardness of computing the shared secret from the public values is equivalent to
the hardness of discrete log.

The \emph{computational Diffie-Hellman assumption} states that computing the
shared secret $g^{x_ax_b}$ from $g^{x_a}$ and $g^{x_b}$ is hard for some choice
of groups.  A stronger assumption, the \emph{decisional Diffie-Hellman
problem}, states that given $g^{x_a}$ and $g^{x_b}$, the shared secret
$g^{x_ax_b}$ is computationally indistinguishable from random for some groups.
This assumption is often not true for groups used in practice; even with safe
primes as defined below, many implementations use a generator that generates
the full group of order $p-1$, rather than the subgroup of order $(p-1)/2$.  This means
that a passive attacker can always learn the value of the secret exponent modulo 2.
To avoid leaking this bit of information about the exponent, both sides could agree to 
compute the shared secret as $y^{2x} \bmod p$.  We have not seen implementations
with this behavior.
%\looseness=-1

There are several families of discrete log algorithms, each of which apply to
special types of groups and parameter choices. Implementations must take care
to avoid choices vulnerable to any particular algorithm. These include:

\paragraph{Small-order groups}
The Pollard rho~\cite{pollard1975monte} and Shanks' baby step-giant step
algorithms~\cite{shanks1971class} each can be used to compute discrete logs in
groups of order $q$ in time $O(\sqrt{q})$.  To avoid being vulnerable,
implementations must choose a group order with bit length at least twice the
desired bit security of the key exchange. In practice, this means that group
orders $q$ should be at least 160 bits for an 80-bit security level.

\paragraph{Composite-order groups}
If the group order $q$ is a composite with prime factorization $q = \prod_i
q_i^{e_i}$, then the attacker can use the Pohlig-Hellman
algorithm~\cite{pohlig1978improved} to compute a discrete log in time $O(\sum_i
e_i \sqrt{q_i})$.  The Pohlig-Hellman algorithm computes the discrete log in
each subgroup of order $q_i^{e_i}$ and then uses the Chinese remainder theorem
to reconstruct the log modulo $q$.  Adrian et al.~\cite{weakdh-ccs15} found
several thousand TLS hosts using primes with composite-order groups, and were
able to compute discrete logs for several hundred Diffie-Hellman key exchanges
using this algorithm.  To avoid being vulnerable, implementations should choose
$g$ so that it generates a subgroup of large prime order modulo $p$.
%\looseness=-1

\paragraph{Short exponents}
If the secret exponent $x_a$ is relatively small or lies within a known range of
values of a relatively small size, $m$, then the Pollard lambda ``kangaroo''
algorithm~\cite{Pollard2000} can be used to find $x_a$ in time $O(\sqrt{m})$.  To
avoid this attack, implementations should choose secret exponents to have bit
length at least twice the desired security level.  For example, using a 256-bit
exponent for for a 128-bit security level.

\paragraph{Small prime moduli} When the subgroup order is not small or
composite, and the prime modulus $p$ is relatively large, the fastest known
algorithm is the number field sieve~\cite{gordon1993discrete}, which runs in
subexponential time in the bit length of $p$, $\exp\left((1.923+o(1))(\log
p)^{1/3} (\log \log p)^{2/3}\right)$. Adrian et al.~recently applied the number field sieve
to attack 512-bit primes in about 90,000 core-hours~\cite{weakdh-ccs15}, and
they argue that attacking 1024-bit primes---which are widely used in
practice---is within the resources of large governments. To avoid this attack,
current recommendations call for $p$ to be at least 2048
bits~\cite{nist-sp-800-57-rev4}. When selecting parameters, implementers should
ensure all attacks take at least as long as the number field sieve for their parameter set.

\subsection{Diffie-Hellman group characteristics}

\paragraph{``Safe'' primes}
In order to maximize the size of the subgroup used for Diffie-Hellman, one can
choose a $p$ such that $p = 2q + 1$ for some prime $q$. Such a $p$ is called a
``safe'' prime, and $q$ is a Sophie Germain prime.  For sufficiently large safe
primes, the best attack will be solving the discrete log using the number field
sieve.
Many standards explicitly specify the use of safe primes for Diffie-Hellman in
practice.  The Oakley protocol~\cite{rfc2412} specified five ``well-known''
groups for Diffie-Hellman in 1998. These included three safe primes of size
768, 1024, and 1536 bits, and was later expanded to include six more groups in
2003~\cite{rfc3526}. The Oakley groups have been built into numerous other
standards, including IKE~\cite{rfc2409} and SSH~\cite{rfc4253}.

%Given a finite field, with a cyclic group modulo some prime, $\mathbb{Z}/p$, and group operations $+$ and $\cdot$. 
%
%Both participants choose an element, $a$ and $b$ respectively, randomly from the integers up to the order of the subgroup. The public keys take the form of $g^a$ and $g^b$ where $g$ is a generator of the subgroup and exponentiation is repeated application of the multiplication operation within the group. Both parties then exponentiate their partners public key by their secret to yield values of $g^{ba}$ and $g^{ab}$ respectively. By the abelian nature of the group these are the same group element, thus yielding a shared secret. 
%
%For the case where the group is sufficiently large, not of smooth order, and $a$ and $b$ are of sufficient length, the Diffie-Hellman assumption posits that that the most efficient way to find the value of $g^{ab}$ given only $g^{a}$ and $g^{b}$ is equivalent to finding a solution to an instance of the discrete log problem, which is assumed hard. However, the above relies on three assumptions that can all be targeted in real implementations of the protocol.
%
%The solution to the DLP can be found if the group has a small number of elements or the exponent is small enough such that there is no 'wrap-around' when the generator is exponentiated, reducing the problem to solving the logarithm in the integers.
%
%A group can be chosen such that it contains a subgroup in which all the prime factors of the generator are smaller than some value $B$, which for integers is called a '$B-smooth$' integer. Then an attacker can solve the discrete log problem in the orders of the factors, and using the Chinese remainder theorem can reconstruct the unique solution in the original group.
%

\paragraph{DSA groups}
The DSA signature algorithm~\cite{dsa} is also based on the hardness of
discrete log.  DSA parameters have a subgroup order $q$ of much smaller size
than $p$.  In this case $p-1 = q r$ where $q$ is prime and $r$ is a large
composite, and $g$ generates a group of order $q$.  FIPS 186-4~\cite{dsa}
specifies 160-bit $q$ for 1024-bit $p$ and 224- or 256-bit $q$ for 2048-bit
$p$.  The small size of the subgroup allows the signature to be much shorter
than the size of $p$.

\subsection{DSA Group Standardization}

DSA-style parameters have also been recommended for use for Diffie-Hellman key
exchange.  NIST Special Publication 800-56A, ``Recommendation for Pair-Wise Key
Establishment Schemes Using Discrete Logarithm
Cryptography''~\cite{barker2007sp}, first published in 2007, specifies that
finite field Diffie-Hellman should be done over a prime-order subgroup $q$ of
size 160 bits for a 1024-bit prime $p$, and a 224- or 256-bit subgroup for a
2048-bit prime.  While the order of the multiplicative subgroups is in line
with the hardness of computing discrete logs in these subgroups, no explanation
is given for recommending a subgroup of precisely this size rather than setting
a minimum subgroup size or using a safe prime.  Using a shorter exponent will
make modular exponentiation more efficient, but the order of the subgroup $q$
does not increase efficiency---on the contrary, the additional modular exponentiation
required to validate that a received key exchange message is contained in the correct
subgroup will render key exchange with DSA primes less efficient than using a ``safe'' 
prime for the same exponent length.  Choosing a small subgroup order is not known to have
much impact on other cryptanalytic attacks, although the number field sieve is
somewhat (not asymptotically) easier as the linear algebra step is performed
modulo the subgroup order $q$.~\cite{weakdh-ccs15}

RFC 5114, ``Additional Diffie-Hellman Groups for Use with IETF
Standards''~\cite{rfc5114}, specifies three DSA groups with the above orders
``for use in IKE, TLS, SSH, etc.''  These groups were taken from test data
published by NIST~\cite{nistffcsamples}. They have been widely implemented in
IPsec and TLS, as we will show below. We refer to these groups as Group 22
(1024-bit group with 160-bit subgroup), Group 23 (2048-bit group with 224-bit
subgroup), and Group 24 (2048-bit group with 256-bit subgroup) throughout the
remainder of the paper to be consistent with the group numbers assigned for
IKE.

RFC 6989, ``Additional Diffie-Hellman Tests for the Internet Key Exchange
Protocol Version 2 (IKEv2)''~\cite{rfc6989}, notes that ``mod $p$'' groups with
small subgroups can be vulnerable to small subgroup attacks, and mandates that
IKE implementations should validate that the received value is in the correct
subgroup or never repeat exponents.

\subsection{Small subgroup attacks}
\label{subsec:small-subgroup-attack}

Since the security of Diffie-Hellman relies crucially on the group parameters,
implementations can be vulnerable to an attacker who provides maliciously
generated parameters that change the properties of the group. 
With the right parameters and implementation decisions, an attaker may be able
to efficiently determine the Diffie-Hellman shared secret. In some cases, a
passive attacker may be able to break a transcript offline.

\paragraph{Small subgroup confinement attacks}
In a small subgroup confinement attack, an attacker (either a man-in-the-middle
or a malicious client or server) provides a key-exchange value $y$ that lies in a
subgroup of small order.  This forces the other party's view of the shared
secret, $y^x$, to lie in the subgroup generated by the attacker.  This
type of attack was described by van Oorschot and Wiener~\cite{van1996diffie}
and ascribed to Vanstone and Anderson and Vaudenay~\cite{Anderson1996}.  Small
subgroup confinement attacks are possible even when the server does not repeat
exponents---the only requirement is that an implementation does not validate
that received Diffie-Hellman key exchange values are in the correct subgroup.

%Consider a simplified Diffie-Hellman key exchange protocol where Alice and Bob negotiate a shared secret $k = g^{ab} \bmod p$ using Diffie-Hellman key exchange, and then Alice symmetrically encrypts a message using the secret $k$ and transmits it to Bob.  Alice might specify a safe prime $p$ and a generator $g$ of order $q = (p-1)/2$, and use a static Diffie-Hellman public value $y_a = g^a \bmod p$.  

When working $\bmod\,p$, there is always a subgroup of order 2, since $p-1$ is
even. A malicious client Mallory could initiate a Diffie-Hellman key exchange
value with Alice and send her the value $y_M = p-1 \equiv -1 \bmod p$, which is
is a generator of the group of order $2 \bmod p$.  When Alice attempts to
compute her view of the shared secret as $k_a = y_M^a \bmod p$, there are only
two possible values, $1$ and $-1 \bmod p$.

The same type of attack works if $p-1$ has other small factors $q_i$.  Mallory
can send a generator $g_i$ of a group of order $q_i$ as her Diffie-Hellman key
exchange value. Alice's view of the shared secret will be an element of the
subgroup of order $q_i$. Mallory then has a $1/q_i$ chance of blindly guessing Alice's
shared secret in this invalid group. Given a message from Alice encrypted using
Alice's view of the shared secret, Mallory can brute force Alice's shared secret in $q_i$ guesses.

 More recently, Bhargavan and
Delignat-Lavaud~\cite{conf/ndss/BhargavanDP15} describe ``key synchronization''
attacks against IKEv2 where a man-in-the-middle connects to both the initiator and
responder in different connections, uses a small subgroup confinement attack
against both, and observes that there is a $1/q_i$ probability of the shared
secrets being the same in both connections.  Bhargavan and Leurent~\cite{sloth}
describe several attacks that use subgroup confinement attacks to obtain a
transcript collision and break protocol authentication.

To protect against subgroup confinement attacks, implementations should use
prime-order subgroups with known subgroup order. Both parties must validate
that the key exchange values they receive are in the proper subgroup. That is,
for a known subgroup order $q$, a received Diffie-Hellman key exchange value
$y$ should satisfy $y^q \equiv 1 \bmod p$.  For a safe prime, it suffices to
check that $y$ is strictly between $1$ and $p-1$. 

\paragraph{Small subgroup key recovery attacks}
Lim and Lee~\cite{Lim1997} discovered a further attack that arises when an
implementation fails to validate subgroup order and resues a static
secret exponent for multiple key exchanges. A malicious party may be able
to perform multiple subgroup confinement attacks for different prime factors
$q_i$ of $p-1$ and then use the Chinese remainder theorem to reconstruct the
static secret exponent.

The attack works as follows.  Let $p-1$ have many small factors $p-1 = q_1 q_2
\dots q_n$.  Mallory, a malicious client, uses the procedure described in
Section~\ref{sec:group-background} to find a generator of the subgroup $g_i$ of
order $q_i \bmod p$.  Then Mallory transmits $g_i$ as her Diffie-Hellman key
exchange value, and receives a message encrypted with Alice's view of the
shared secret $g_i^{x_a}$, which Mallory can brute force to learn the value of
$x_a \bmod q_i$.  Once Mallory has repeated this process several times, she can
use the Chinese remainder theorem to reconstruct $x_a \bmod \prod_i q_i$.  The
running time of this attack is $\sum_i q_i$, assuming that Mallory performs an
offline brute-force search for each subgroup.

A randomly chosen prime $p$ is likely to have subgroups of large enough order
that this attack is infeasible to carry out for all subgroups.  However, if in
addition Alice's secret exponent $x_a$ is small, then Mallory only needs to carry out this
attack for a subset of subgroups of orders $q_1, \dots, q_k$ satisfying
$\prod_{i=0}^k q_i > x_a$, since the Chinese remainder theorem ensures that $x_a$
will be uniquely defined.
Mallory can also improve on the running time of the attack by taking advantage
of the Pollard lambda algorithm.  That is, she could use a small subgroup
attack to learn the value of $x_a \bmod \prod_{i=1}^k q_i$ for a subset of
subgroups $\prod_{i=1}^k q_i < x_a$, and then use the Pollard lambda algorithm to
reconstruct the full value of $a$, as it has now been confined to a smaller
interval.

In summary, an implementation is vulnerable to small subgroup key recovery
attacks if it does not verify that received Diffie-Hellman key exchange values
are in the correct subgroup; uses a prime $p$ such that $p-1$ has small
factors; and reuses Diffie-Hellman secret exponent values.  The attack is made
even more practical if the implementation uses small exponents.

A related attack exists for elliptic curve groups: an invalid curve attack.
Similarly to the case we describe above, the attacker generates a series of
elliptic curve points of small order and sends these
points as key exchange messages to the victim.  If the victim does not validate that the received
point is on the intended curve, they return a response that reveals information
about the secret key modulo different group orders.  After enough queries, the
attacker can learn the victim's entire secret.  Jager, Schwenk, and
Somorovsky~\cite{Jager2015} examined eight elliptic curve implementations and
discovered two that failed to validate the received curve point. For elliptic
curve groups, this attack can be much more devastating because the attacker has
much more freedom in generating different curves, and can thus find many
different small prime order subgroups.  For the finite field Diffie-Hellman
attack, the attacker is limited only to those subgroups whose orders are factors
of $p-1$.

